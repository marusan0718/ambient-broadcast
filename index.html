<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ambient Music</title>

  <meta name="theme-color" content="#ffffff" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/15.3.5/Tone.js"></script>

  <style>
    summary::-webkit-details-marker { display:none; }
    .ios-scroll { -webkit-overflow-scrolling: touch; }
    .glass {
      background: rgba(255,255,255,.72);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }
    input[type="range"]{ accent-color:#0f172a; }
  </style>
</head>

<body class="min-h-screen text-slate-900">
  <main class="min-h-screen flex items-center justify-center p-5 sm:p-8">
    <div class="w-full max-w-xl">
      <div class="rounded-[28px] border border-white/70 glass shadow-[0_20px_60px_rgba(15,23,42,0.10)] overflow-hidden">
        <div class="px-6 sm:px-8 pt-7 pb-5">
          <div class="flex items-start justify-between gap-3">
            <div>
              <div class="inline-flex items-center gap-2 rounded-full bg-white/80 border border-slate-200 px-3 py-1 text-xs text-slate-600">
                <span id="dot" class="inline-block size-2 rounded-full bg-slate-400"></span>
                <span id="modeText">Ready</span>
              </div>

              <h1 class="mt-3 text-2xl font-semibold tracking-tight">Ambient Music</h1>

              <p class="mt-1 text-sm text-slate-600">季節、天気、風のゆらぎ。</p>
              <p class="mt-1 text-sm text-slate-600">この瞬間の自然と呼吸を合わせ、音は静かに生まれていく。</p>
            </div>

            <div class="text-right">
              <div class="text-[10px] sm:text-xs text-slate-500 whitespace-nowrap">自動更新</div>
              <div id="countdown" class="mt-1 text-sm font-medium text-slate-700 tabular-nums">—</div>
            </div>
          </div>

          <button id="btnToggle"
            class="mt-5 w-full rounded-3xl px-5 py-6 sm:py-7 transition active:scale-[0.99]
                   bg-slate-900 text-white hover:bg-slate-800
                   shadow-[0_18px_40px_rgba(15,23,42,0.22)]">
            <div class="flex items-center justify-center gap-4">
              <div class="grid place-items-center size-12 rounded-2xl bg-white/10 border border-white/15">
                <svg id="iconSvg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor" class="opacity-95">
                  <path d="M8 5v14l11-7z"></path>
                </svg>
              </div>
              <div class="text-left">
                <div id="btnLabel" class="text-xl font-semibold">Start</div>
                <div id="btnSub" class="text-xs text-white/75">タップで再生</div>
              </div>
            </div>
          </button>

          <div class="mt-4">
            <div class="rounded-2xl bg-white/75 border border-slate-200 px-4 py-3">
              <div class="flex items-center justify-between">
                <div class="text-xs text-slate-500">状態</div>
                <div id="statusChip" class="text-[11px] text-slate-500 tabular-nums"></div>
              </div>
              <div id="statusMain" class="mt-1 text-base font-medium text-slate-800">待機中</div>
              <div id="statusSub" class="mt-0.5 text-[12px] text-slate-600">—</div>
            </div>
          </div>
        </div>

        <div class="border-t border-white/70 bg-white/55">
          <div class="px-6 sm:px-8 py-4 flex items-center justify-between gap-3">
            <button id="btnRefresh"
              class="px-4 py-2 rounded-2xl text-sm bg-white/80 border border-slate-200 hover:bg-white active:scale-[0.99]">
              更新
            </button>

            <details id="settingsDetails" class="group">
              <summary
                class="list-none cursor-pointer select-none px-4 py-2 rounded-2xl text-sm
                       bg-white/80 border border-slate-200 hover:bg-white active:scale-[0.99]
                       inline-flex items-center gap-2">
                設定
                <span class="text-slate-400 group-open:rotate-180 transition">▾</span>
              </summary>
            </details>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Settings Overlay -->
  <div id="settingsOverlay" class="fixed inset-0 z-50 hidden">
    <div id="settingsBackdrop" class="absolute inset-0 bg-slate-900/10 backdrop-blur-[2px]"></div>

    <div class="absolute inset-0 flex items-end sm:items-center justify-center p-3 sm:p-6">
      <div class="w-full max-w-[560px] rounded-[28px] bg-white/95 border border-slate-200 shadow-2xl overflow-hidden">
        <div class="px-5 sm:px-6 pt-4 pb-3 border-b border-slate-200">
          <div class="flex items-center justify-between gap-3">
            <div class="text-sm font-semibold text-slate-800">設定</div>
            <button id="btnCloseSettings"
              class="px-3 py-1.5 rounded-xl text-sm bg-slate-900 text-white hover:bg-slate-800 active:scale-[0.99]">
              閉じる
            </button>
          </div>

          <div class="mt-3 flex gap-2">
            <button data-tab="tabSettings"
              class="tabBtn flex-1 px-3 py-2 rounded-2xl text-sm border border-slate-200 bg-slate-900 text-white">
              設定
            </button>
            <button data-tab="tabGuide"
              class="tabBtn flex-1 px-3 py-2 rounded-2xl text-sm border border-slate-200 bg-white text-slate-700 hover:bg-slate-50">
              仕組み
            </button>
          </div>
        </div>

        <div class="px-5 sm:px-6 py-4 max-h-[70vh] overflow-y-auto ios-scroll">
          <section id="tabSettings" class="space-y-4">
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
              <div>
                <div class="text-xs text-slate-500 mb-1">季節</div>
                <select id="seasonSel" class="w-full rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm">
                  <option value="auto">Auto</option>
                  <option value="spring">春</option>
                  <option value="summer">夏</option>
                  <option value="autumn">秋</option>
                  <option value="winter">冬</option>
                </select>
              </div>
              <div>
                <div class="text-xs text-slate-500 mb-1">時間</div>
                <select id="timeSel" class="w-full rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm">
                  <option value="auto">Auto</option>
                  <option value="morning">朝</option>
                  <option value="day">昼</option>
                  <option value="evening">夕</option>
                  <option value="night">夜</option>
                  <option value="late">深夜</option>
                </select>
              </div>
              <div>
                <div class="text-xs text-slate-500 mb-1">天気</div>
                <select id="weatherSel" class="w-full rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm">
                  <option value="auto">Auto</option>
                  <option value="clear">晴れ</option>
                  <option value="rain">雨</option>
                  <option value="other">その他</option>
                </select>
              </div>
            </div>

            <div class="rounded-2xl border border-violet-100 bg-gradient-to-br from-violet-50 via-white to-sky-50 p-5 shadow-sm">
              <div class="text-sm font-semibold text-slate-800">自然音の頻度（手動）</div>
              <p class="mt-1 text-xs text-slate-600">
                Autoは「時間帯・天気」に合わせて自動。手動にすると、ここで頻度を上書きできます。
              </p>

              <div class="mt-3 space-y-4">
                <div class="rounded-2xl bg-white border border-slate-200 p-4">
                  <div class="flex items-center justify-between gap-3">
                    <div class="text-sm font-medium text-slate-800">鳥</div>
                    <div class="flex items-center gap-2">
                      <select id="birdMode" class="rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm">
                        <option value="auto">Auto</option>
                        <option value="manual">手動</option>
                      </select>
                      <div class="text-xs text-slate-500 w-20 text-right tabular-nums">
                        <span id="birdVal">—</span>
                      </div>
                    </div>
                  </div>
                  <div class="mt-3">
                    <input id="birdFreq" type="range" min="0" max="100" value="55" class="w-full" />
                    <div class="mt-1 flex justify-between text-[11px] text-slate-500">
                      <span>少</span><span>多</span>
                    </div>
                  </div>
                </div>

                <div class="rounded-2xl bg-white border border-slate-200 p-4">
                  <div class="flex items-center justify-between gap-3">
                    <div class="text-sm font-medium text-slate-800">風</div>
                    <div class="flex items-center gap-2">
                      <select id="windMode" class="rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm">
                        <option value="auto">Auto</option>
                        <option value="manual">手動</option>
                      </select>
                      <div class="text-xs text-slate-500 w-20 text-right tabular-nums">
                        <span id="windVal">—</span>
                      </div>
                    </div>
                  </div>
                  <div class="mt-3">
                    <input id="windFreq" type="range" min="0" max="100" value="45" class="w-full" />
                    <div class="mt-1 flex justify-between text-[11px] text-slate-500">
                      <span>少</span><span>多</span>
                    </div>
                  </div>
                </div>

                <div class="rounded-2xl bg-white border border-slate-200 p-4">
                  <div class="flex items-center justify-between gap-3">
                    <div class="text-sm font-medium text-slate-800">水</div>
                    <div class="flex items-center gap-2">
                      <select id="waterMode" class="rounded-xl border border-slate-300 bg-white px-3 py-2 text-sm">
                        <option value="auto">Auto</option>
                        <option value="manual">手動</option>
                      </select>
                      <div class="text-xs text-slate-500 w-20 text-right tabular-nums">
                        <span id="waterVal">—</span>
                      </div>
                    </div>
                  </div>
                  <div class="mt-3">
                    <input id="waterFreq" type="range" min="0" max="100" value="50" class="w-full" />
                    <div class="mt-1 flex justify-between text-[11px] text-slate-500">
                      <span>少</span><span>多</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <section id="tabGuide" class="hidden">
            <div class="rounded-2xl border border-slate-200 bg-slate-50 p-4">
              <div class="text-sm font-semibold text-slate-800">このアプリの仕組み</div>
              <p class="mt-2 text-sm text-slate-700 leading-relaxed">
                自然の値をそのまま音量に結びつけるのではなく、心地よさのバランスを守りながら、キーやテンポ、光の明るさ、きらめきの密度へとそっと織り込んでいます。
              </p>
            </div>

            <div class="mt-3 space-y-3">
              <details class="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm">
                <summary class="cursor-pointer select-none flex items-center justify-between">
                  <span class="text-sm font-medium text-slate-800">季節（キー・調）</span>
                  <span class="text-slate-400">▾</span>
                </summary>
                <div class="mt-3 text-sm text-slate-700 leading-relaxed">
                  春はC、夏はD、秋はEb、冬はA。<br>
                  季節ごとにそっと基調となるキーを定めています。ハーモニーときらめきは常に同じ調の中で揺らぐため、音の世界が崩れることはありません。
                </div>
              </details>

              <details class="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm">
                <summary class="cursor-pointer select-none flex items-center justify-between">
                  <span class="text-sm font-medium text-slate-800">時間（テンポ・空気感）</span>
                  <span class="text-slate-400">▾</span>
                </summary>
                <div class="mt-3 text-sm text-slate-700 leading-relaxed">
                  朝と昼は、わずかに速く。夜と深夜は、ゆっくりと。体感の“呼吸”を時間帯に寄せながら、背景の色も静かに移ろいます。
                </div>
              </details>

              <details class="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm">
                <summary class="cursor-pointer select-none flex items-center justify-between">
                  <span class="text-sm font-medium text-slate-800">天気（明るさ・残響）</span>
                  <span class="text-slate-400">▾</span>
                </summary>
                <div class="mt-3 text-sm text-slate-700 leading-relaxed">
                  晴れの日は、光をひらくように明るく。余韻は軽やかに整え、空気を澄ませます。雨の日は、少しだけ陰影を深めて。残響を重ね、しっとりとした余白をまとわせています。
                </div>
              </details>

              <details class="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm">
                <summary class="cursor-pointer select-none flex items-center justify-between">
                  <span class="text-sm font-medium text-slate-800">風（ゆらぎ）</span>
                  <span class="text-slate-400">▾</span>
                </summary>
                <div class="mt-3 text-sm text-slate-700 leading-relaxed">
                  風が強まるほど、きらめきはわずかに増えていきます。<br>
                  けれど決して騒がしくはならないように。瞬きが少しだけ増える、そのくらいの余白にとどめています。
                </div>
              </details>

              <details class="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm">
                <summary class="cursor-pointer select-none flex items-center justify-between">
                  <span class="text-sm font-medium text-slate-800">UV（きらめき）</span>
                  <span class="text-slate-400">▾</span>
                </summary>
                <div class="mt-3 text-sm text-slate-700 leading-relaxed">
                  光が強い日中は、空気の透明度を少し高め、余韻を引き締めます。<br>
                  きらりと差し込む光の感触を添えて、昼の心地よさをそっと押し上げます。
                </div>
              </details>

              <details class="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm">
                <summary class="cursor-pointer select-none flex items-center justify-between">
                  <span class="text-sm font-medium text-slate-800">鳥（さえずり）</span>
                  <span class="text-slate-400">▾</span>
                </summary>
                <div class="mt-3 text-sm text-slate-700 leading-relaxed">
                  朝から昼にかけてほんの少しだけ添えています。主役にならないよう、短いフレーズと単発を織り交ぜながら、空気に自然と溶け込む範囲にとどめています。夜と深夜は、その静けさを何よりも優先します。
                </div>
              </details>

              <details class="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm">
                <summary class="cursor-pointer select-none flex items-center justify-between">
                  <span class="text-sm font-medium text-slate-800">ハーモニー</span>
                  <span class="text-slate-400">▾</span>
                </summary>
                <div class="mt-3 text-sm text-slate-700 leading-relaxed">
その調の中でも穏やかな三和音だけを選び、安心して身を預けられる響きを紡いでいます。
                </div>
              </details>
            </div>
          </section>
        </div>
      </div>
    </div>
  </div>

<script>
  // =========================
  // Weather + UV (Open-Meteo)
  // =========================
  const OPEN_METEO_URL = "https://api.open-meteo.com/v1/forecast";
  const AUTO_UPDATE_MS = 5 * 60 * 1000;
  let nextUpdateAt = Date.now() + AUTO_UPDATE_MS;

  function describeWeather(code) {
    if (code === 0) return "快晴";
    if ([1,2].includes(code)) return "晴れ/薄曇り";
    if (code === 3) return "くもり";
    if ([45,48].includes(code)) return "霧";
    if ([51,53,55,56,57].includes(code)) return "霧雨";
    if ([61,63,65,66,67].includes(code)) return "雨";
    if ([71,73,75,77].includes(code)) return "雪";
    if ([80,81,82].includes(code)) return "にわか雨";
    if ([95,96,99].includes(code)) return "雷雨";
    return "不明";
  }

  function weatherCategoryFromCode(code) {
    if (code === 0 || [1,2].includes(code)) return "clear";
    if ([61,63,65,66,67,80,81,82,51,53,55,56,57,95,96,99].includes(code)) return "rain";
    return "other";
  }

  async function fetchWeatherByCoords(lat, lon) {
    const url = new URL(OPEN_METEO_URL);
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("current", "weather_code,wind_speed_10m");
    url.searchParams.set("daily", "uv_index_max");
    url.searchParams.set("timezone", "auto");

    const res = await fetch(url.toString());
    if (!res.ok) throw new Error("天気取得に失敗しました");
    const data = await res.json();

    const code = data?.current?.weather_code;
    const wind = data?.current?.wind_speed_10m;
    const uvArr = data?.daily?.uv_index_max;
    const uv = Array.isArray(uvArr) ? uvArr[0] : null;

    if (typeof code !== "number" || typeof wind !== "number") throw new Error("天気データ形式が想定と違います");
    return { code, wind, uv: (typeof uv === "number" ? uv : null) };
  }

  function getCurrentPosition() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) return reject(new Error("このブラウザは位置情報に対応していません"));
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        enableHighAccuracy: false,
        timeout: 8000,
        maximumAge: 60_000,
      });
    });
  }

  // =========================
  // Wake Lock
  // =========================
  let wakeLock = null;
  async function requestWakeLock(){
    try{
      if (!("wakeLock" in navigator)) return;
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release", () => { wakeLock = null; });
    } catch(e){}
  }
  async function releaseWakeLock(){
    try{ if (wakeLock) await wakeLock.release(); } catch(e){}
    wakeLock = null;
  }
  document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === "visible" && isRunning){
      await requestWakeLock();
    }
  });

  // =========================
  // Env helpers
  // =========================
  function autoTimeBlock(){
    const h = new Date().getHours();
    if (h >= 5 && h < 10) return "morning";
    if (h >= 10 && h < 16) return "day";
    if (h >= 16 && h < 19) return "evening";
    if (h >= 19 && h < 24) return "night";
    return "late";
  }

  function autoSeason(){
    const m = new Date().getMonth() + 1;
    if (m >= 3 && m <= 5) return "spring";
    if (m >= 6 && m <= 8) return "summer";
    if (m >= 9 && m <= 11) return "autumn";
    return "winter";
  }

  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
  function clamp01(x){ return clamp(x, 0, 1); }
  function randomBetween(min, max){ return min + Math.random() * (max - min); }
  function randInt(min, max){ return Math.floor(min + Math.random() * (max - min + 1)); }
  function choose(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

  function setStatus(main, sub = "—") {
    const a = document.getElementById("statusMain");
    const b = document.getElementById("statusSub");
    if (!a || !b) return;
    a.textContent = main;
    b.textContent = sub;
  }

  function setStatusChip(text = ""){
    const el = document.getElementById("statusChip");
    if (!el) return;
    el.textContent = text;
  }

  function setStatusChipVisibility(time){
    const el = document.getElementById("statusChip");
    if (!el) return;
    const hide = (time === "night" || time === "late");
    el.classList.toggle("hidden", hide);
    if (hide) el.textContent = "";
  }

  function applyWhiteByTime(time){
    const map = {
      morning: ["from-sky-50",   "via-white", "to-slate-100"],
      day:     ["from-white",    "via-white", "to-slate-100"],
      evening: ["from-amber-50", "via-white", "to-rose-100"],
      night:   ["from-slate-50", "via-white", "to-slate-200"],
      late:    ["from-slate-50", "via-white", "to-slate-200"],
    };
    const [a,b,c] = map[time] || map.day;
    document.body.className = `min-h-screen text-slate-900 bg-gradient-to-b ${a} ${b} ${c}`;
  }

  // =========================
  // Media Session
  // =========================
  function setMediaSessionMetadata(text){
    if (!("mediaSession" in navigator)) return;
    try{
      navigator.mediaSession.metadata = new MediaMetadata({
        title: "Ambient Music",
        artist: text,
        album: "Nature Sync"
      });

      navigator.mediaSession.setActionHandler("play",  async () => { if (!isRunning) await start(); });
      navigator.mediaSession.setActionHandler("pause", () => { if (isRunning) stop(); });
    } catch(e){}
  }

  function updatePlaybackState(){
    if (!("mediaSession" in navigator)) return;
    try{
      navigator.mediaSession.playbackState = isRunning ? "playing" : "paused";
    } catch(e){}
  }

  // =========================
  // Manual frequency settings
  // =========================
  function readRange01(id){
    const v = Number(document.getElementById(id).value || 0);
    return clamp(v / 100, 0, 1);
  }
  function modeOf(id){ return document.getElementById(id).value; }

  function uiFreqFactor(kind, r){
    const modeId = kind + "Mode";
    const rangeId = kind + "Freq";

    if (modeOf(modeId) === "manual"){
      return readRange01(rangeId);
    }

    if (kind === "bird"){
      let base = 0.55;
      if (r.time === "day") base = 0.70;
      if (r.time === "morning") base = 0.62;
      if (r.time === "evening") base = 0.52;
      if (r.time === "night") base = 0.20;
      if (r.time === "late") base = 0.08;
      if (r.weatherCat === "rain") base *= 0.70;
      return clamp(base, 0, 1);
    }

    if (kind === "wind"){
      const w = clamp(lastWeather.wind ?? 0, 0, 15);
      let base = 0.45 + 0.40 * (w/15);
      if (r.time === "late") base *= 0.70;
      if (r.time === "night") base *= 0.82;
      if (r.weatherCat === "rain") base *= 0.90;
      return clamp(base, 0, 1);
    }

    if (kind === "water"){
      let base = (r.weatherCat === "rain") ? 0.62 : 0.46;
      if (r.time === "late") base *= 0.78;
      if (r.time === "night") base *= 0.88;
      return clamp(base, 0, 1);
    }
    return 0.5;
  }

  function updateFreqLabels(){
    if (!lastComputedR) return;
    const r = lastComputedR;

    const b = uiFreqFactor("bird", r);
    const w = uiFreqFactor("wind", r);
    const a = uiFreqFactor("water", r);

    document.getElementById("birdVal").textContent  = Math.round(b*100) + "%";
    document.getElementById("windVal").textContent  = Math.round(w*100) + "%";
    document.getElementById("waterVal").textContent = Math.round(a*100) + "%";

    document.getElementById("birdFreq").disabled  = (modeOf("birdMode") !== "manual");
    document.getElementById("windFreq").disabled  = (modeOf("windMode") !== "manual");
    document.getElementById("waterFreq").disabled = (modeOf("waterMode") !== "manual");

    document.getElementById("birdFreq").classList.toggle("opacity-40", modeOf("birdMode") !== "manual");
    document.getElementById("windFreq").classList.toggle("opacity-40", modeOf("windMode") !== "manual");
    document.getElementById("waterFreq").classList.toggle("opacity-40", modeOf("waterMode") !== "manual");
  }

  // =========================
  // Music
  // =========================
  let isRunning = false;

  let masterReverb, masterComp, masterLimiter, masterOut;
  let filter;

  let sparkle;
  let bird, birdFilter, birdTremolo;

  let windNoise, windFilter, windGain;
  let waterNoise, waterFilter, waterGain;

  let sparkleMulti = null;
  let sparkleAutoPanner = null;
  let sparkleHitPanner = null;
  let sparkleRhythmReverb = null;

  let sparkleLoop, birdLoop, windLoop, waterLoop;
  let chordEventId = null;

  // cajon
  let cajonBody = null;
  let cajonSnap = null;
  let cajonGain = null;
  let cajonReverb = null;
  let cajonEventId = null;

  // gamelan (NEW)
  let gamelan = null;
  let gamelanGain = null;
  let gamelanReverb = null;
  let gamelanDelay = null;
  let gamelanEventId = null;

  let lastWeather = { code: 0, wind: 0, uv: null };
  let lastRoot = null;

  let lastComputedR = null;
  let transportGuardTimer = null;
  let isStopping = false;

  const activeChordTimers = new Set();
  const activeChordNodes = new Set();

  function disposeAllChords(){
    activeChordTimers.forEach(tid => { try{ clearTimeout(tid); } catch(e){} });
    activeChordTimers.clear();

    activeChordNodes.forEach(node => { try{ node.dispose(); } catch(e){} });
    activeChordNodes.clear();
  }

  function scheduleDispose(nodeA, nodeB, atAudioTimeSec){
    const now = Tone.now();
    const ms = Math.max(0, (atAudioTimeSec - now) * 1000);

    activeChordNodes.add(nodeA);
    activeChordNodes.add(nodeB);

    const tid = setTimeout(() => {
      try{ nodeA.dispose(); } catch(e){}
      try{ nodeB.dispose(); } catch(e){}
      activeChordNodes.delete(nodeA);
      activeChordNodes.delete(nodeB);
      activeChordTimers.delete(tid);
    }, ms);

    activeChordTimers.add(tid);
  }

  function ensureAudioGraph(){
    if (sparkle) return;

    masterOut = new Tone.Gain(0.0001).toDestination();
    masterReverb = new Tone.Reverb({ decay: 14.5, wet: 0.42 }).connect(masterOut);
    masterComp = new Tone.Compressor({ threshold: -18, ratio: 2.2, attack: 0.01, release: 0.22 }).connect(masterReverb);
    masterLimiter = new Tone.Limiter(-1).connect(masterComp);

    filter = new Tone.Filter({ type: "lowpass", frequency: 1900, rolloff: -12 }).connect(masterLimiter);

    sparkleRhythmReverb = new Tone.Reverb({ decay: 14.0, wet: 0.48, preDelay: 0.03 });
    sparkleAutoPanner = new Tone.AutoPanner({ frequency: 0.10, depth: 0.85, wet: 1.0 }).start();
    sparkleHitPanner = new Tone.Panner(0);
    sparkleAutoPanner.connect(sparkleHitPanner);
    sparkleHitPanner.connect(sparkleRhythmReverb);
    sparkleRhythmReverb.connect(filter);

    sparkle = new Tone.Synth({
      oscillator: { type: "sine" },
      envelope: { attack: 0.016, decay: 0.36, sustain: 0.0, release: 3.8 }
    });
    sparkle.volume.value = -12;

    birdTremolo = new Tone.Tremolo({ frequency: 9, depth: 0.65, wet: 1.0 }).start();
    birdFilter = new Tone.Filter({ type: "bandpass", frequency: 2300, Q: 6 });
    bird = new Tone.Synth({
      oscillator: { type: "sine" },
      envelope: { attack: 0.004, decay: 0.07, sustain: 0.0, release: 0.17 }
    });
    bird.chain(birdTremolo, birdFilter, filter);
    bird.volume.value = -19;

    windNoise = new Tone.Noise("pink").start();
    windFilter = new Tone.Filter({ type: "bandpass", frequency: 420, Q: 0.9 });
    windGain = new Tone.Gain(0.000001);
    windNoise.chain(windFilter, windGain, filter);

    waterNoise = new Tone.Noise("brown").start();
    waterFilter = new Tone.Filter({ type: "lowpass", frequency: 900, rolloff: -12 });
    waterGain = new Tone.Gain(0.000001);
    waterNoise.chain(waterFilter, waterGain, filter);

    // =========================
    // Cajon
    // =========================
    cajonReverb = new Tone.Reverb({
      decay: 22.0,
      wet: 0.72,
      preDelay: 0.02
    });

    cajonGain = new Tone.Gain(0.12);
    cajonGain.connect(cajonReverb);
    cajonReverb.connect(filter);

    cajonBody = new Tone.MembraneSynth({
      pitchDecay: 0.02,
      octaves: 2.2,
      oscillator: { type: "sine" },
      envelope: { attack: 0.001, decay: 0.20, sustain: 0.0, release: 0.20 }
    });
    cajonBody.volume.value = -18;
    cajonBody.connect(cajonGain);

    cajonSnap = new Tone.NoiseSynth({
      noise: { type: "white" },
      envelope: { attack: 0.001, decay: 0.045, sustain: 0.0, release: 0.05 }
    });
    cajonSnap.volume.value = -26;
    cajonSnap.connect(cajonGain);

    // =========================
    // Gamelan (NEW) — metallic bell-ish
    // =========================
    gamelanGain = new Tone.Gain(0.06);
    gamelanReverb = new Tone.Reverb({ decay: 26.0, wet: 0.78, preDelay: 0.015 });
    gamelanDelay = new Tone.FeedbackDelay({ delayTime: 0.18, feedback: 0.22, wet: 0.18 });

    // Route: gamelan -> gain -> delay -> deep reverb -> filter
    gamelanGain.connect(gamelanDelay);
    gamelanDelay.connect(gamelanReverb);
    gamelanReverb.connect(filter);

    gamelan = new Tone.MetalSynth({
      frequency: 220,
      envelope: { attack: 0.001, decay: 1.8, release: 0.9 },
      harmonicity: 6.0,
      modulationIndex: 24,
      resonance: 2800,
      octaves: 1.2
    });
    gamelan.volume.value = -18;
    gamelan.connect(gamelanGain);
  }

  function keyFromSeason(season){
    if (season === "spring") return "C";
    if (season === "summer") return "D";
    if (season === "autumn") return "Eb";
    if (season === "winter") return "A";
    return "C";
  }

  function chordChoicesForKey(key){
    const map = {
      "C":  ["C4","D4","E4","F4","G4","A4"],
      "D":  ["D4","E4","F#4","G4","A4","B4"],
      "Eb": ["Eb4","F4","G4","Ab4","Bb4","C5"],
      "A":  ["A3","B3","C#4","D4","E4","F#4"]
    };
    return map[key] || map["C"];
  }

  function triad(rootNote){
    const r = Tone.Frequency(rootNote);
    return [ r.toNote(), r.transpose(4).toNote(), r.transpose(7).toNote() ];
  }

  function sparkleScale(key, weatherCat, time){
    const major = {
      "C":  ["C5","D5","E5","F5","G5","A5","B5","C6"],
      "D":  ["D5","E5","F#5","G5","A5","B5","C#6","D6"],
      "Eb": ["Eb5","F5","G5","Ab5","Bb5","C6","D6","Eb6"],
      "A":  ["A4","B4","C#5","D5","E5","F#5","G#5","A5"],
    };
    const pent = {
      "C":  ["C5","D5","E5","G5","A5","C6"],
      "D":  ["D5","E5","F#5","A5","B5","D6"],
      "Eb": ["Eb5","F5","G5","Bb5","C6","Eb6"],
      "A":  ["A4","B4","C#5","E5","F#5","A5"],
    };
    const usePent = (weatherCat === "rain") || (time === "night" || time === "late");
    return usePent ? (pent[key] || pent["C"]) : (major[key] || major["C"]);
  }

  function transposeNotes(arr, semis){
    return arr.map(n => Tone.Frequency(n).transpose(semis).toNote());
  }

  function sparkleScaleWithLow(key, weatherCat, time){
    const hi = sparkleScale(key, weatherCat, time);
    const lo1 = transposeNotes(hi, -12);
    const lo2 = transposeNotes(hi, -24);
    return { hi, lo1, lo2 };
  }

  function pickRhythmNote(scalePack, r){
    let lowP = 0.16;
    if (r.time === "day" || r.time === "morning") lowP = 0.12;
    if (r.time === "evening") lowP = 0.16;
    if (r.time === "night") lowP = 0.22;
    if (r.time === "late") lowP = 0.26;
    if (r.weatherCat === "rain") lowP += 0.05;
    lowP = clamp(lowP, 0.08, 0.38);

    const roll = Math.random();
    if (roll < lowP * 0.70) return choose(scalePack.lo1);
    if (roll < lowP) return choose(scalePack.lo2);
    return choose(scalePack.hi);
  }

  function getEnv(){
    const seasonSel = document.getElementById("seasonSel").value;
    const timeSel   = document.getElementById("timeSel").value;
    const weatherSel= document.getElementById("weatherSel").value;

    const season = (seasonSel === "auto") ? autoSeason() : seasonSel;
    const time   = (timeSel === "auto") ? autoTimeBlock() : timeSel;
    const weatherCat = (weatherSel === "auto") ? weatherCategoryFromCode(lastWeather.code) : weatherSel;

    return { season, time, weatherCat };
  }

  function prettyTimeLabel(t){
    if (t === "morning") return "朝";
    if (t === "day") return "昼";
    if (t === "evening") return "夕";
    if (t === "night") return "夜";
    if (t === "late") return "深夜";
    return t;
  }
  function prettyWeatherLabel(w){
    if (w === "clear") return "晴れ";
    if (w === "rain") return "雨";
    if (w === "other") return "その他";
    return w;
  }

  function applyParams(){
    const env = getEnv();
    const key = keyFromSeason(env.season);

    applyWhiteByTime(env.time);

    let bpm = 66;
    if (env.time === "morning") bpm = 74;
    if (env.time === "day") bpm = 78;
    if (env.time === "evening") bpm = 70;
    if (env.time === "night") bpm = 60;
    if (env.time === "late") bpm = 54;
    Tone.Transport.bpm.value = bpm;

    let cutoff = 1900, wet = 0.42, decay = 14.5;
    if (env.weatherCat === "clear") { cutoff = 2800; wet = 0.34; decay = 12.0; }
    if (env.weatherCat === "other") { cutoff = 1900; wet = 0.44; decay = 14.0; }
    if (env.weatherCat === "rain")  { cutoff = 1350; wet = 0.52; decay = 16.5; }

    const uv = (typeof lastWeather.uv === "number") ? lastWeather.uv : null;
    const isDay = (env.time === "day" || env.time === "morning" || env.time === "evening");
    if (uv !== null && isDay){
      const u = clamp(uv / 11, 0, 1);
      cutoff += 560 * u;
      wet    -= 0.06 * u;
      decay  -= 1.2 * u;
    }

    filter.frequency.value = clamp(cutoff, 950, 3600);
    masterReverb.wet.value = clamp(wet, 0.28, 0.70);
    masterReverb.decay = clamp(decay, 9.0, 20.0);

    if (birdFilter){
      birdFilter.frequency.value = (env.weatherCat === "rain") ? 1950 : 2350;
    }

    if (sparkleAutoPanner){
      let f = 0.10;
      if (env.time === "day") f = 0.13;
      if (env.time === "morning") f = 0.12;
      if (env.time === "evening") f = 0.11;
      if (env.time === "night") f = 0.085;
      if (env.time === "late") f = 0.070;
      sparkleAutoPanner.frequency.value = f;
      sparkleAutoPanner.depth = (env.weatherCat === "rain") ? 0.75 : 0.85;
    }

    if (sparkleRhythmReverb){
      let rhythmWet = 0.48;
      let rhythmDecay = 14.0;
      if (env.time === "day" || env.time === "morning") { rhythmWet = 0.42; rhythmDecay = 12.2; }
      if (env.time === "night" || env.time === "late") { rhythmWet = 0.56; rhythmDecay = 16.8; }
      if (env.weatherCat === "rain") { rhythmWet += 0.06; rhythmDecay += 1.4; }
      sparkleRhythmReverb.wet.value = clamp(rhythmWet, 0.34, 0.72);
      sparkleRhythmReverb.decay = clamp(rhythmDecay, 10.0, 22.0);
    }

    if (windFilter){
      windFilter.frequency.value = (env.weatherCat === "rain") ? 360 : 420;
      windFilter.Q.value = (env.time === "late") ? 1.1 : 0.9;
    }
    if (waterFilter){
      waterFilter.frequency.value = (env.weatherCat === "rain") ? 760 : 900;
    }

    // cajon feel
    if (cajonReverb){
      let cWet = 0.72;
      let cDec = 22.0;
      if (env.weatherCat === "rain") { cWet = 0.78; cDec = 24.0; }
      if (env.time === "late") { cWet += 0.04; cDec += 1.5; }
      if (env.time === "night") { cWet += 0.02; cDec += 0.8; }
      cajonReverb.wet.value = clamp(cWet, 0.60, 0.92);
      cajonReverb.decay = clamp(cDec, 14.0, 30.0);
    }
    if (cajonGain){
      let g = 0.12;
      if (env.time === "day" || env.time === "morning") g = 0.10;
      if (env.time === "evening") g = 0.12;
      if (env.time === "night") g = 0.13;
      if (env.time === "late") g = 0.14;
      if (env.weatherCat === "rain") g *= 1.06;
      cajonGain.gain.value = clamp(g, 0.06, 0.18);
    }

    // gamelan feel (NEW)
    if (gamelanReverb){
      let gWet = 0.78;
      let gDec = 26.0;
      if (env.weatherCat === "rain") { gWet = 0.82; gDec = 28.0; }
      if (env.time === "late") { gWet += 0.03; gDec += 1.4; }
      if (env.time === "night") { gWet += 0.02; gDec += 0.8; }
      gamelanReverb.wet.value = clamp(gWet, 0.62, 0.92);
      gamelanReverb.decay = clamp(gDec, 14.0, 32.0);
    }
    if (gamelanDelay){
      let dWet = 0.18;
      let fb = 0.22;
      if (env.time === "day" || env.time === "morning") { dWet = 0.16; fb = 0.20; }
      if (env.time === "night" || env.time === "late") { dWet = 0.20; fb = 0.24; }
      if (env.weatherCat === "rain") { dWet += 0.03; fb += 0.02; }
      gamelanDelay.wet.value = clamp(dWet, 0.10, 0.36);
      gamelanDelay.feedback.value = clamp(fb, 0.12, 0.36);
    }
    if (gamelanGain){
      let g = 0.06;
      if (env.time === "day") g = 0.055;
      if (env.time === "morning") g = 0.055;
      if (env.time === "evening") g = 0.060;
      if (env.time === "night") g = 0.065;
      if (env.time === "late") g = 0.070;
      if (env.weatherCat === "rain") g *= 1.06;
      gamelanGain.gain.value = clamp(g, 0.03, 0.10);
    }
    if (gamelan){
      // 金属っぽさ調整（時間でほんの少し）
      let res = 2800;
      if (env.time === "late") res = 2400;
      if (env.time === "night") res = 2550;
      if (env.weatherCat === "rain") res -= 150;
      gamelan.resonance = clamp(res, 1600, 3400);
    }

    const windText = `${(lastWeather.wind ?? 0).toFixed(1)} m/s`;
    const showUv = !(env.time === "night" || env.time === "late");
    const uvText = (showUv && uv !== null) ? uv.toFixed(1) : "—";
    const uvSegment = showUv ? ` / UV ${uvText}` : "";
    setMediaSessionMetadata(`${env.season} / ${env.weatherCat} / wind ${windText}${uvSegment}`);

    const sub =
      `Key ${key} · ${prettyTimeLabel(env.time)} · ${prettyWeatherLabel(env.weatherCat)} · 風 ${(lastWeather.wind ?? 0).toFixed(1)}` +
      (showUv ? ` · UV ${uvText}` : "");
    setStatusChipVisibility(env.time);
    if (showUv) setStatusChip("同期中");
    if (isRunning) setStatus("再生中", sub);

    lastComputedR = { ...env, key, bpm };
    updateFreqLabels();

    return lastComputedR;
  }

  function clearHarmonyScheduler(){
    if (chordEventId !== null){
      try { Tone.Transport.clear(chordEventId); } catch(e){}
      chordEventId = null;
    }
  }

  function startTransportGuard(){
    if (transportGuardTimer) return;
    transportGuardTimer = setInterval(async () => {
      if (!isRunning) return;
      try {
        if (Tone.context.state !== "running") {
          await Tone.start();
        }
        if (Tone.Transport.state !== "started") {
          Tone.Transport.start();
        }
      } catch (e) {
        console.warn("transport guard", e);
      }
    }, 12000);
  }

  function stopTransportGuard(){
    if (!transportGuardTimer) return;
    clearInterval(transportGuardTimer);
    transportGuardTimer = null;
  }

  function clearCajonScheduler(){
    if (cajonEventId !== null){
      try { Tone.Transport.clear(cajonEventId); } catch(e){}
      cajonEventId = null;
    }
  }

  function clearGamelanScheduler(){
    if (gamelanEventId !== null){
      try { Tone.Transport.clear(gamelanEventId); } catch(e){}
      gamelanEventId = null;
    }
  }

  function harmonyDurationSeconds(r){
    let min = 24.0;
    let max = 56.0;

    if (r.time === "morning") { min = 22.0; max = 48.0; }
    if (r.time === "day") { min = 20.0; max = 44.0; }
    if (r.time === "evening") { min = 26.0; max = 54.0; }
    if (r.time === "night") { min = 30.0; max = 62.0; }
    if (r.time === "late") { min = 44.0; max = 96.0; }

    if (r.weatherCat === "rain") {
      min += 4.0;
      max += 8.0;
    }

    const shortChance = (r.time === "day" || r.time === "morning") ? 0.34 : 0.20;
    if (Math.random() < shortChance) {
      return randomBetween(min * 0.62, min * 0.90);
    }

    const longChance = (r.time === "night" || r.time === "late") ? 0.42 : 0.26;
    if (Math.random() < longChance) {
      return randomBetween(max * 0.82, max * 1.12);
    }

    return randomBetween(min, max);
  }

  function harmonyGapSeconds(r){
    let g = randomBetween(0.6, 2.2);

    const burstChance =
      (r.time === "day" || r.time === "morning") ? 0.30 :
      (r.time === "evening") ? 0.24 :
      (r.time === "night") ? 0.18 :
      0.12;

    if (Math.random() < burstChance){
      g *= randomBetween(0.25, 0.55);
    }

    if (r.time === "late") g *= 1.55;
    if (r.time === "night") g *= 1.10;
    if (r.weatherCat === "rain") g *= 1.06;

    return clamp(g, 0.22, 3.8);
  }

  function octaveShifted(note, octShift){
    const f = Tone.Frequency(note);
    return f.transpose(12 * octShift).toNote();
  }

  function pickOverlapMode(r){
    let base = 0.68;
    if (r.time === "day" || r.time === "morning") base = 0.76;
    if (r.time === "evening") base = 0.70;
    if (r.time === "night") base = 0.58;
    if (r.time === "late") base = 0.24;
    if (r.weatherCat === "rain") base *= 0.92;

    if (Math.random() >= base) return "none";

    let earlyWeight = 0.78;
    if (r.time === "late") earlyWeight = 0.62;
    if (r.time === "night") earlyWeight = 0.70;
    if (r.weatherCat === "rain") earlyWeight *= 0.95;

    return (Math.random() < earlyWeight) ? "early" : "tail";
  }

  function playOneHarmony(startTime, r){
    const choices = chordChoicesForKey(r.key);

    let root = choices[Math.floor(Math.random() * choices.length)];
    if (root === lastRoot) root = choices[Math.floor(Math.random() * choices.length)];
    lastRoot = root;

    const playDur = harmonyDurationSeconds(r);
    const gapDur  = harmonyGapSeconds(r);

    let oct = choose([-1, 0, 0, 0, +1, +1]);
    if (Math.random() < 0.10) oct = choose([-2, +2]);
    const shiftedRoot = octaveShifted(root, oct);

    const chordGain = new Tone.Gain(0.000001).connect(filter);
    const chordPad = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: "sine" },
      envelope: { attack: 2.2, decay: 0.6, sustain: 0.82, release: 18.0 }
    }).connect(chordGain);

    chordPad.volume.value = -18;

    let peak = 0.15 + Math.random() * 0.17;
    if (r.time === "night") peak *= 0.70;
    if (r.time === "late") peak *= 0.56;
    if (r.weatherCat === "rain") peak *= 0.86;

    const t0 = startTime;
    const tPeak = startTime + playDur * (0.35 + Math.random() * 0.35);
    const tEnd = startTime + playDur;

    chordGain.gain.setValueAtTime(0.00012, t0);
    chordGain.gain.exponentialRampToValueAtTime(Math.max(0.00018, peak), tPeak);
    chordGain.gain.exponentialRampToValueAtTime(0.00012, tEnd);

    chordPad.triggerAttackRelease(triad(shiftedRoot), playDur, startTime, 0.72);

    const disposeAt = tEnd + 22.0;
    scheduleDispose(chordPad, chordGain, disposeAt);

    const mode = pickOverlapMode(r);
    let nextTime = startTime + playDur + gapDur;

    if (mode === "tail"){
      nextTime = tEnd + randomBetween(-10.0, 6.0);
      nextTime = Math.max(nextTime, startTime + 7.0);
    } else if (mode === "early"){
      const frac = randomBetween(0.30, 0.70);
      nextTime = startTime + playDur * frac;
    }

    chordEventId = Tone.Transport.scheduleOnce((t) => {
      const rr = applyParams();
      playOneHarmony(t, rr);
    }, nextTime);
  }

  // =========================
  // Rhythm: MultiTap Delay (4〜7 taps)
  // =========================
  function buildMultiTapDelay(){
    if (sparkleMulti){
      sparkleMulti.tapNodes.forEach(n => { try{ n.dispose(); } catch(e){} });
      try{ sparkleMulti.input.dispose(); } catch(e){}
      try{ sparkleMulti.merger.dispose(); } catch(e){}
      sparkleMulti = null;
    }

    const taps = randInt(4, 7);

    const merger = new Tone.Gain(1).connect(sparkleAutoPanner);
    const wetBase = randomBetween(0.40, 0.62);

    const tapNodes = [];
    for (let i = 0; i < taps; i++){
      const dt = randomBetween(0.03, 0.23);
      const fb = randomBetween(0.18, 0.44) * (1 - i*0.08);
      const wt = clamp(wetBase * (0.85 - i*0.06), 0.18, 0.65);

      const d = new Tone.FeedbackDelay({ delayTime: dt, feedback: fb, wet: wt });
      d.connect(merger);
      tapNodes.push(d);
    }

    const input = new Tone.Gain(1);
    tapNodes.forEach(d => input.connect(d));

    sparkleMulti = { input, tapNodes, merger };
    return sparkleMulti;
  }

  function pickSparkleDelayRefreshChance(r){
    if (r.time === "day") return 0.003;
    if (r.time === "morning") return 0.002;
    if (r.time === "evening") return 0.0015;
    if (r.time === "night") return 0.0;
    return 0.0;
  }

  function rebuildSparkleDelayIfNeeded(r){
    if (!sparkleMulti){
      buildMultiTapDelay();
      sparkle.disconnect();
      sparkle.connect(sparkleMulti.input);
      return;
    }
    if (Math.random() < pickSparkleDelayRefreshChance(r)){
      buildMultiTapDelay();
      sparkle.disconnect();
      sparkle.connect(sparkleMulti.input);
    }
  }

  function randomRhythmDuration(r){
    const dayish = (r.time === "morning" || r.time === "day");
    const nightish = (r.time === "night" || r.time === "late");

// note-length pools
const short = ["16n","12n","8t","8n"];
const mid   = ["8n","6n","4t","4n"];
const long  = ["4n","3n","2n","1m"];

let pool = [...short, ...mid, ...mid];
if (dayish)   pool = [...short, ...mid, ...mid, ...long];
if (nightish) pool = [...mid, ...long, ...long, ...mid];
if (r.weatherCat === "rain") pool = [...pool, ...long, "1m"];

const d = choose(pool);

// interval seconds (add gentle jitter, keep safe bounds)
const sec = Tone.Time(d).toSeconds() * randomBetween(0.92, 1.45);
return clamp(sec, 0.28, 2.80);


    let pool = [...short, ...mid, ...mid];
    if (dayish) pool = [...short, ...mid, ...mid, ...long];
    if (nightish) pool = [...mid, ...long, ...long, ...mid];
    if (r.weatherCat === "rain") pool = [...pool, ...long, "1m"];

    const d = choose(pool);
// note-length pools
const short = ["16n","12n","8t","8n"];
const mid   = ["8n","6n","4t","4n"];
const long  = ["4n","3n","2n","1m"];

let pool = [...short, ...mid, ...mid];
if (dayish)   pool = [...short, ...mid, ...mid, ...long];
if (nightish) pool = [...mid, ...long, ...long, ...mid];
if (r.weatherCat === "rain") pool = [...pool, ...long, "1m"];

const d = choose(pool);

// interval seconds (add gentle jitter, keep safe bounds)
const sec = Tone.Time(d).toSeconds() * randomBetween(0.92, 1.45);
return clamp(sec, 0.28, 2.80);

  }

  function applyHitPan(time, r){
    if (!sparkleHitPanner) return;

    let width = 0.85;
    if (r.weatherCat === "rain") width = 0.70;
    if (r.time === "night") width = 0.62;
    if (r.time === "late") width = 0.52;
    if (r.time === "day") width = 0.92;

    const target = (Math.random() * 2 - 1) * width;
    sparkleHitPanner.pan.cancelScheduledValues(time);
    sparkleHitPanner.pan.setValueAtTime(sparkleHitPanner.pan.value, time);
    sparkleHitPanner.pan.linearRampToValueAtTime(target, time + 0.06);
  }

  // =========================
  // Cajon: random note-values + deep reverb only
  // =========================
  function cajonDensity(r){
    let p = 0.22;
    if (r.time === "morning") p = 0.26;
    if (r.time === "day")     p = 0.28;
    if (r.time === "evening") p = 0.24;
    if (r.time === "night")   p = 0.18;
    if (r.time === "late")    p = 0.14;
    if (r.weatherCat === "rain") p *= 1.08;
    return clamp(p, 0.06, 0.45);
  }

  function cajonDurPool(r){
    const dayish = (r.time === "morning" || r.time === "day");
    const nightish = (r.time === "night" || r.time === "late");

    const short = ["16n","16t","32n"];
    const mid   = ["8n","8t","12n","24n"];
    const long  = ["4n","6n"];

    let pool = [...short, ...mid];
    if (dayish) pool = [...short, ...short, ...mid, "16n", "8n"];
    if (nightish) pool = [...mid, ...mid, ...long, "8n"];
    if (r.weatherCat === "rain") pool = [...pool, ...long];
    return pool;
  }

  function cajonNextStepSeconds(r){
    const d = choose(cajonDurPool(r));
    let sec = Tone.Time(d).toSeconds();
    sec *= randomBetween(0.92, 1.08);
    return clamp(sec, 0.08, 1.25);
  }

  function cajonHit(time, r){
    if (!cajonBody || !cajonSnap) return;

    const roll = Math.random();
    const isNight = (r.time === "night" || r.time === "late");

    let v = 0.30 + Math.random()*0.22;
    if (isNight) v *= 0.82;
    if (r.weatherCat === "rain") v *= 0.92;

    const bodyNote = choose(["C1","D1","E1","G1"]);
    if (roll < 0.55){
      cajonBody.triggerAttackRelease(bodyNote, 0.06, time, v);
    } else if (roll < 0.85){
      cajonSnap.triggerAttackRelease(0.03, time, v*0.70);
    } else {
      cajonBody.triggerAttackRelease(bodyNote, 0.05, time, v*0.95);
      cajonSnap.triggerAttackRelease(0.028, time + 0.004, v*0.60);
    }

    const ghostChance = isNight ? 0.10 : 0.16;
    if (Math.random() < ghostChance){
      const t2 = time + randomBetween(0.05, 0.14);
      cajonSnap.triggerAttackRelease(0.02, t2, v*0.35);
      if (!isNight && Math.random() < 0.35){
        cajonBody.triggerAttackRelease(bodyNote, 0.045, t2 + 0.01, v*0.40);
      }
    }
  }

  function startCajonScheduler(startTime, r){
    clearCajonScheduler();

    const step = (t) => {
      const rr = applyParams();
      const p = cajonDensity(rr);
      if (Math.random() < p){
        cajonHit(t, rr);
      }
      const next = t + cajonNextStepSeconds(rr);
      cajonEventId = Tone.Transport.scheduleOnce(step, next);
    };

    cajonEventId = Tone.Transport.scheduleOnce(step, startTime);
  }

  // =========================
  // Gamelan (NEW)
  // =========================
  // ざっくり「スレンドロ/ペログ風」：等間隔っぽい・少しズレた周波数群（厳密再現ではなく雰囲気）
  function gamelanScaleHz(r){
    // 基音（季節キーに寄せた雰囲気）— 実音はHzで扱う
    const baseMap = { C: 196.0, D: 220.0, Eb: 207.65, A: 220.0 }; // Aは同じでもOK
    const base = baseMap[r.key] || 196.0;

    const slendro = [1.00, 1.12, 1.26, 1.41, 1.58]; // 5音っぽい
    const pelog   = [1.00, 1.07, 1.20, 1.34, 1.50, 1.67, 1.90]; // 7音っぽい（偏り）

    const usePelog = (r.weatherCat === "rain") || (r.time === "evening");
    const ratios = usePelog ? pelog : slendro;

    // octave spread
    const oct = (r.time === "late" || r.time === "night") ? choose([0, 0, 1]) : choose([0,1,1,2]);
    const mul = Math.pow(2, oct);

    // ほんの少し個体差（ガムランっぽいピッチの揺れ）
    const jitter = () => (1 + randomBetween(-0.008, 0.008));

    return ratios.map(x => base * x * mul * jitter());
  }

  function gamelanDensity(r){
    // ガムランは“点描”にする（カフォンより少なめ）
    let p = 0.12;
    if (r.time === "morning") p = 0.13;
    if (r.time === "day")     p = 0.14;
    if (r.time === "evening") p = 0.12;
    if (r.time === "night")   p = 0.09;
    if (r.time === "late")    p = 0.07;
    if (r.weatherCat === "rain") p *= 1.10;
    return clamp(p, 0.03, 0.22);
  }

  function gamelanDurPool(r){
    const nightish = (r.time === "night" || r.time === "late");
    const short = ["16n","16t","32n"];
    const mid   = ["8n","8t","12n","24n"];
    const long  = ["4n","6n"];

    let pool = [...short, ...mid];
    if (nightish) pool = [...mid, ...mid, ...long, "8n"];
    if (r.weatherCat === "rain") pool = [...pool, ...long];
    return pool;
  }

  function gamelanNextStepSeconds(r){
    const d = choose(gamelanDurPool(r));
    let sec = Tone.Time(d).toSeconds();
    // ちょいゆらぎ
    sec *= randomBetween(0.90, 1.10);
    // 詰まりすぎない
    return clamp(sec, 0.10, 1.60);
  }

  function setGamelanFrequencyAt(hz, time){
    if (!gamelan) return;
    if (gamelan.frequency && typeof gamelan.frequency.setValueAtTime === "function"){
      gamelan.frequency.setValueAtTime(hz, time);
      return;
    }
    if (gamelan.frequency && typeof gamelan.frequency.value === "number"){
      gamelan.frequency.value = hz;
      return;
    }
    gamelan.frequency = hz;
  }

  function gamelanHit(time, r){
    if (!gamelan) return;

    const scale = gamelanScaleHz(r);
    const hz = choose(scale);

    // ベロシティ（夜は控えめ）
    const isNight = (r.time === "night" || r.time === "late");
    let v = 0.14 + Math.random()*0.10;
    if (isNight) v *= 0.78;
    if (r.weatherCat === "rain") v *= 0.90;

    // 打ち方：単発 / 2連 / 3連をちょい混ぜ
    const roll = Math.random();

    // まず周波数をセット（MetalSynthはfrequencyを読む）
    setGamelanFrequencyAt(hz, time);

    if (roll < 0.70){
      gamelan.triggerAttackRelease("16n", time, v);
    } else if (roll < 0.90){
      gamelan.triggerAttackRelease("16n", time, v);
      setGamelanFrequencyAt(hz * choose([1.00, 1.12, 0.89]), time + randomBetween(0.01, 0.03));
      gamelan.triggerAttackRelease("32n", time + randomBetween(0.06, 0.12), v*0.70);
    } else {
      // 小さめの3連（点描のきらめき）
      const gaps = [0.06, 0.10, 0.14].map(x => x + randomBetween(-0.01, 0.01));
      for (let i=0; i<3; i++){
        setGamelanFrequencyAt(hz * choose([1.00, 1.12, 1.26, 0.89]), time + gaps[i]);
        gamelan.triggerAttackRelease("32n", time + gaps[i], v*(0.62 - i*0.10));
      }
    }
  }

  function startGamelanScheduler(startTime, r){
    clearGamelanScheduler();

    const step = (t) => {
      const rr = applyParams();
      const p = gamelanDensity(rr);
      if (Math.random() < p){
        gamelanHit(t, rr);
      }
      const next = t + gamelanNextStepSeconds(rr);
      gamelanEventId = Tone.Transport.scheduleOnce(step, next);
    };

    gamelanEventId = Tone.Transport.scheduleOnce(step, startTime);
  }

  // =========================
  // Wind / Water swells
  // =========================
  function windBaseLevel(r){
    const w = clamp(lastWeather.wind ?? 0, 0, 15);
    let base = 0.00006 + 0.00010 * (w / 15);
    if (r.time === "night") base *= 0.78;
    if (r.time === "late") base *= 0.65;
    if (r.weatherCat === "rain") base *= 0.90;

    const f = uiFreqFactor("wind", r);
    const gainMul = clamp(0.35 + 1.10 * f, 0.20, 1.60);
    base *= gainMul;

    return clamp(base, 0.00001, 0.00028);
  }

  function waterBaseLevel(r){
    let base = 0.00004;
    if (r.weatherCat === "rain") base = 0.00008;
    if (r.time === "night") base *= 0.85;
    if (r.time === "late") base *= 0.70;

    const f = uiFreqFactor("water", r);
    const gainMul = clamp(0.35 + 1.10 * f, 0.20, 1.60);
    base *= gainMul;

    return clamp(base, 0.00001, 0.00020);
  }

  function triggerWindGust(time, r){
    if (!windGain) return;
    const base = windBaseLevel(r);

    const ff = uiFreqFactor("wind", r);
    const peak = clamp(base * randomBetween(1.8, 4.6) * (0.70 + 0.90*ff), 0.00003, 0.00085);
    const dur = randomBetween(2.4, 6.8);

    windGain.gain.cancelScheduledValues(time);
    windGain.gain.setValueAtTime(Math.max(0.000001, windGain.gain.value), time);
    windGain.gain.exponentialRampToValueAtTime(Math.max(0.000001, peak), time + 0.7);
    windGain.gain.exponentialRampToValueAtTime(Math.max(0.000001, base), time + dur);
  }

  function triggerWaterRipple(time, r){
    if (!waterGain) return;
    const base = waterBaseLevel(r);

    const ff = uiFreqFactor("water", r);
    const peak = clamp(base * randomBetween(1.6, 3.2) * (0.75 + 0.90*ff), 0.00003, 0.00070);
    const dur = randomBetween(1.4, 4.6);

    waterGain.gain.cancelScheduledValues(time);
    waterGain.gain.setValueAtTime(Math.max(0.000001, waterGain.gain.value), time);
    waterGain.gain.exponentialRampToValueAtTime(Math.max(0.000001, peak), time + 0.25);
    waterGain.gain.exponentialRampToValueAtTime(Math.max(0.000001, base), time + dur);
  }

  // =========================
  // Loops
  // =========================
  function rebuildLoops(){
    disposeAllChords();
    Tone.Transport.cancel(0);

    if (sparkleLoop) { sparkleLoop.dispose(); sparkleLoop = null; }
    if (birdLoop) { birdLoop.dispose(); birdLoop = null; }
    if (windLoop) { windLoop.dispose(); windLoop = null; }
    if (waterLoop) { waterLoop.dispose(); waterLoop = null; }
    clearHarmonyScheduler();
    clearCajonScheduler();
    clearGamelanScheduler();

    const r = applyParams();

    const now = Tone.now();
    if (windGain) windGain.gain.setValueAtTime(Math.max(0.000001, windBaseLevel(r)), now);
    if (waterGain) waterGain.gain.setValueAtTime(Math.max(0.000001, waterBaseLevel(r)), now);

    const startAt = Tone.Transport.seconds + 0.1;

    chordEventId = Tone.Transport.scheduleOnce((t) => playOneHarmony(t, r), startAt);

    startCajonScheduler(startAt + 0.2, r);
    startGamelanScheduler(startAt + 0.25, r);

    rebuildSparkleDelayIfNeeded(r);

    const sparkleInterval = 0.52;
    sparkleLoop = new Tone.Loop((time) => {
      rebuildSparkleDelayIfNeeded(r);

      const pack = sparkleScaleWithLow(r.key, r.weatherCat, r.time);

      let p = 0.60;
      if (r.weatherCat === "rain") p = 0.50;
      if (r.time === "late") p = 0.36;
      if (r.time === "night") p = Math.min(p, 0.44);
      if (r.weatherCat === "clear" && (r.time === "day" || r.time === "morning")) p = 0.70;

      const windBoost = clamp(((lastWeather.wind ?? 0) - 2) / 10, 0, 0.14);
      p += windBoost;

      const uv = (typeof lastWeather.uv === "number") ? lastWeather.uv : null;
      if (uv !== null && (r.time === "day" || r.time === "morning")){
        const u = clamp(uv / 11, 0, 1);
        p += 0.12 * u;
      }
      p = clamp(p, 0.14, 0.82);

      if (Math.random() < p){
        applyHitPan(time, r);

        const note = pickRhythmNote(pack, r);
        const durSec = randomRhythmDuration(r);

        const isLowish = Tone.Frequency(note).toMidi() < Tone.Frequency(pack.hi[0]).toMidi();
        let amp = 0.40 + Math.random() * 0.12;
        if (isLowish) amp *= 0.78;

        if (Math.random() < 0.16){
          const note2 = pickRhythmNote(pack, r);
          const dur2 = clamp(durSec * randomBetween(0.78, 1.28), 0.24, 2.40);
          const isLow2 = Tone.Frequency(note2).toMidi() < Tone.Frequency(pack.hi[0]).toMidi();
          const amp2 = isLow2 ? amp*0.78 : amp*0.82;

          sparkle.triggerAttackRelease(note,  durSec, time,        amp);
          sparkle.triggerAttackRelease(note2, dur2,  time + 0.02,  amp2);
        } else {
          sparkle.triggerAttackRelease(note, durSec, time, amp);
        }
      }
    }, sparkleInterval).start(0);

    function autoBirdChance(r){
      let base = 0.08;
      if (r.time === "morning") base = 0.18;
      if (r.time === "day")     base = 0.26;
      if (r.time === "evening") base = 0.14;
      if (r.time === "night")   base = 0.04;
      if (r.time === "late")    base = 0.018;

      if (r.weatherCat === "rain")  base *= 0.70;
      if (r.weatherCat === "clear" && (r.time === "day" || r.time === "morning")) base *= 1.10;

      const w = clamp(lastWeather.wind ?? 0, 0, 15);
      base *= (1.0 + 0.12 * (w / 15));

      const uv = (typeof lastWeather.uv === "number") ? lastWeather.uv : null;
      if (uv !== null && r.time === "day") {
        const u = clamp(uv / 11, 0, 1);
        base *= (1.0 + 0.12 * u);
      }
      return clamp(base, 0.010, 0.40);
    }

    function birdChance(r){
      const auto = autoBirdChance(r);
      const f = uiFreqFactor("bird", r);
      const mul = (modeOf("birdMode") === "manual")
        ? clamp(0.0 + 1.7 * f, 0.0, 1.7)
        : 1.0;
      return clamp(auto * mul, 0.0, 0.55);
    }

    function chirp(time, amp = 0.30){
      const base = 1450 + Math.random()*700;
      const up   = base + 980 + Math.random()*560;
      const dur  = 0.055 + Math.random()*0.070;

      bird.frequency.setValueAtTime(base, time);
      bird.frequency.linearRampToValueAtTime(up, time + dur);
      bird.frequency.linearRampToValueAtTime(base + 240, time + dur + 0.03);

      bird.triggerAttackRelease("C6", dur + 0.06, time, amp);
    }

    function phrase(time){
      const n = (Math.random() < 0.50) ? 2 : (Math.random() < 0.80 ? 3 : 5);
      const baseGap = 0.10 + Math.random()*0.09;

      for (let i = 0; i < n; i++){
        const t = time + i*(baseGap + Math.random()*0.06);
        const amp = 0.26 + Math.random()*0.12;
        chirp(t, amp);
      }
    }

    function birdLoopIntervalSeconds(r){
      if (r.time === "day") return 1.55;
      if (r.time === "morning") return 1.70;
      if (r.time === "evening") return 2.05;
      if (r.time === "night") return 2.80;
      return 3.40;
    }

    birdLoop = new Tone.Loop((time) => {
      if (!bird) return;

      const p = birdChance(r);
      if (Math.random() < p){
        if (r.time === "night" || r.time === "late"){
          chirp(time, 0.23);
          if (Math.random() < 0.22) chirp(time + 0.16 + Math.random()*0.10, 0.21);
          return;
        }

        const roll = Math.random();
        if (roll < 0.46){
          chirp(time, 0.28 + Math.random()*0.10);
          if (Math.random() < (r.time === "day" ? 0.62 : 0.46)){
            chirp(time + 0.12 + Math.random()*0.12, 0.24 + Math.random()*0.10);
          }
        } else if (roll < 0.80){
          const n = (Math.random() < 0.55) ? 2 : 4;
          for (let i=0; i<n; i++){
            chirp(time + i*(0.11 + Math.random()*0.10), 0.23 + Math.random()*0.12);
          }
        } else {
          phrase(time);
        }
      }
    }, birdLoopIntervalSeconds(r)).start(0);

    function windLoopInterval(r){
      if (r.time === "day") return 3.2;
      if (r.time === "morning") return 3.6;
      if (r.time === "evening") return 4.0;
      if (r.time === "night") return 5.0;
      return 6.2;
    }

    windLoop = new Tone.Loop((time) => {
      const ff = uiFreqFactor("wind", r);
      const w = clamp(lastWeather.wind ?? 0, 0, 15);
      let pAuto = 0.20 + 0.35 * (w / 15);
      if (r.time === "late") pAuto *= 0.70;
      if (r.weatherCat === "rain") pAuto *= 0.90;
      pAuto = clamp(pAuto, 0.06, 0.72);

      const p = (modeOf("windMode") === "manual")
        ? clamp(0.02 + 0.95 * ff, 0.02, 0.95)
        : pAuto;

      if (Math.random() < p){
        triggerWindGust(time, r);
      }
    }, windLoopInterval(r)).start(0);

    function waterLoopInterval(r){
      if (r.weatherCat === "rain") return 3.0;
      if (r.time === "day") return 4.2;
      if (r.time === "morning") return 4.6;
      if (r.time === "evening") return 5.0;
      if (r.time === "night") return 6.2;
      return 7.2;
    }

    waterLoop = new Tone.Loop((time) => {
      const ff = uiFreqFactor("water", r);

      let pAuto = (r.weatherCat === "rain") ? 0.44 : 0.26;
      if (r.time === "late") pAuto *= 0.75;
      if (r.time === "night") pAuto *= 0.85;
      pAuto = clamp(pAuto, 0.08, 0.60);

      const p = (modeOf("waterMode") === "manual")
        ? clamp(0.02 + 0.95 * ff, 0.02, 0.95)
        : pAuto;

      if (Math.random() < p){
        triggerWaterRipple(time, r);
      }
    }, waterLoopInterval(r)).start(0);
  }

  function setButtonState(){
    const dot = document.getElementById("dot");
    const modeText = document.getElementById("modeText");
    const btn = document.getElementById("btnToggle");
    const label = document.getElementById("btnLabel");
    const sub = document.getElementById("btnSub");
    const iconSvg = document.getElementById("iconSvg");

    if (isRunning){
      dot.className = "inline-block size-2 rounded-full bg-emerald-500";
      modeText.textContent = "Playing";
      btn.classList.remove("bg-slate-900","hover:bg-slate-800");
      btn.classList.add("bg-rose-600","hover:bg-rose-500");
      label.textContent = "Stop";
      sub.textContent = "タップで停止";
      iconSvg.innerHTML = '<path d="M6 6h5v12H6zM13 6h5v12h-5z"></path>';
    } else {
      dot.className = "inline-block size-2 rounded-full bg-slate-400";
      modeText.textContent = "Ready";
      btn.classList.remove("bg-rose-600","hover:bg-rose-500");
      btn.classList.add("bg-slate-900","hover:bg-slate-800");
      label.textContent = "Start";
      sub.textContent = "タップで再生";
      iconSvg.innerHTML = '<path d="M8 5v14l11-7z"></path>';
      setStatusChip("");
      setStatus("待機中", "—");
    }
    updatePlaybackState();
  }

  async function start(){
    if (isStopping) return;
    ensureAudioGraph();
    await Tone.start();
    await requestWakeLock();

    const now = Tone.now();
    if (masterOut){
      masterOut.gain.cancelScheduledValues(now);
      masterOut.gain.setValueAtTime(Math.max(0.0001, masterOut.gain.value), now);
      masterOut.gain.exponentialRampToValueAtTime(1.0, now + 1.4);
    }

    Tone.Transport.start();
    rebuildLoops();
    isRunning = true;
    startTransportGuard();
    setButtonState();
    applyParams();
  }

  async function stop(){
    if (isStopping) return;
    isStopping = true;
    isRunning = false;

    try{
      const fadeSeconds = 1.8;
      const now = Tone.now();
      if (masterOut){
        masterOut.gain.cancelScheduledValues(now);
        masterOut.gain.setValueAtTime(Math.max(0.0001, masterOut.gain.value), now);
        masterOut.gain.exponentialRampToValueAtTime(0.0001, now + fadeSeconds);
      }

      await new Promise(resolve => setTimeout(resolve, Math.floor(fadeSeconds * 1000)));

      clearHarmonyScheduler();
    clearCajonScheduler();
    clearGamelanScheduler();

    if (sparkleLoop) { sparkleLoop.stop(); sparkleLoop.dispose(); sparkleLoop = null; }
    if (birdLoop)    { birdLoop.stop(); birdLoop.dispose(); birdLoop = null; }
    if (windLoop)    { windLoop.stop(); windLoop.dispose(); windLoop = null; }
    if (waterLoop)   { waterLoop.stop(); waterLoop.dispose(); waterLoop = null; }

    Tone.Transport.stop();
    Tone.Transport.cancel(0);

    disposeAllChords();

    if (sparkleMulti){
      sparkleMulti.tapNodes.forEach(n => { try{ n.dispose(); } catch(e){} });
      try{ sparkleMulti.input.dispose(); } catch(e){}
      try{ sparkleMulti.merger.dispose(); } catch(e){}
      sparkleMulti = null;
    }

    try{
      if (windGain) windGain.gain.setValueAtTime(0.000001, now);
      if (waterGain) waterGain.gain.setValueAtTime(0.000001, now);
      if (cajonGain) cajonGain.gain.setValueAtTime(Math.max(0.06, cajonGain.gain.value * 0.9), now);
      if (gamelanGain) gamelanGain.gain.setValueAtTime(Math.max(0.03, gamelanGain.gain.value * 0.9), now);
    } catch(e){}

      setStatusChip("");
      setStatusChipVisibility("late");
      setStatus("停止中", "—");
      setButtonState();
      stopTransportGuard();

      releaseWakeLock();
    } finally {
      isStopping = false;
    }
  }

  async function refreshWeather(){
    try{
      setStatusChip("");
      setStatus("取得中…", "天気/風");

      const pos = await getCurrentPosition();
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      const { code, wind, uv } = await fetchWeatherByCoords(lat, lon);
      lastWeather = { code, wind, uv };

      nextUpdateAt = Date.now() + AUTO_UPDATE_MS;

      applyParams();

      if (isRunning){
        applyParams();
      } else {
        const env = getEnv();
        const key = keyFromSeason(env.season);
        const showUv = !(env.time === "night" || env.time === "late");
        const uvText = (typeof lastWeather.uv === "number") ? lastWeather.uv.toFixed(1) : "—";
        const sub =
          `Key ${key} · ${prettyTimeLabel(env.time)} · ${prettyWeatherLabel(env.weatherCat)} · 風 ${(lastWeather.wind ?? 0).toFixed(1)}` +
          (showUv ? ` · UV ${uvText}` : "");
        setStatusChipVisibility(env.time);
        if (showUv) setStatusChip("同期中");
        setStatus("待機中", sub);
      }
    } catch(e){
      console.error(e);
      setStatusChip("");
      setStatusChipVisibility("late");
      setStatus("エラー", e.message);
    }
  }

  function tick(){
    const remain = Math.max(0, nextUpdateAt - Date.now());
    const mm = String(Math.floor(remain/60000)).padStart(2,"0");
    const ss = String(Math.floor((remain%60000)/1000)).padStart(2,"0");
    document.getElementById("countdown").textContent = `${mm}:${ss}`;
    if (remain === 0) refreshWeather();
    requestAnimationFrame(tick);
  }

  // =========================
  // Settings overlay + Tabs
  // =========================
  const settingsDetails = document.getElementById("settingsDetails");
  const settingsOverlay = document.getElementById("settingsOverlay");
  const settingsBackdrop = document.getElementById("settingsBackdrop");
  const btnCloseSettings = document.getElementById("btnCloseSettings");

  const tabButtons = Array.from(document.querySelectorAll(".tabBtn"));
  const tabSettings = document.getElementById("tabSettings");
  const tabGuide = document.getElementById("tabGuide");

  function setTab(id){
    const isSettings = (id === "tabSettings");
    tabSettings.classList.toggle("hidden", !isSettings);
    tabGuide.classList.toggle("hidden", isSettings);

    tabButtons.forEach(btn => {
      const active = btn.dataset.tab === id;
      btn.className =
        "tabBtn flex-1 px-3 py-2 rounded-2xl text-sm border border-slate-200 " +
        (active
          ? "bg-slate-900 text-white"
          : "bg-white text-slate-700 hover:bg-slate-50");
    });
  }

  function openSettings(){
    settingsOverlay.classList.remove("hidden");
    settingsDetails.open = false;
    document.documentElement.classList.add("overflow-hidden");
    document.body.classList.add("overflow-hidden");
    setTab("tabSettings");
    updateFreqLabels();
  }

  function closeSettings(){
    settingsOverlay.classList.add("hidden");
    document.documentElement.classList.remove("overflow-hidden");
    document.body.classList.remove("overflow-hidden");
  }

  settingsDetails.addEventListener("toggle", () => {
    if (settingsDetails.open) openSettings();
  });

  btnCloseSettings.addEventListener("click", closeSettings);
  settingsBackdrop.addEventListener("click", closeSettings);

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeSettings();
  });

  tabButtons.forEach(btn => {
    btn.addEventListener("click", () => setTab(btn.dataset.tab));
  });

  document.getElementById("btnToggle").addEventListener("click", async () => {
    if (!isRunning) await start();
    else await stop();
  });

  document.getElementById("btnRefresh").addEventListener("click", () => refreshWeather());

  ["seasonSel","timeSel","weatherSel"].forEach(id => {
    document.getElementById(id).addEventListener("change", () => {
      applyParams();
    });
  });

  ["birdMode","windMode","waterMode","birdFreq","windFreq","waterFreq"].forEach(id => {
    document.getElementById(id).addEventListener("input", () => {
      updateFreqLabels();
      if (isRunning && lastComputedR){
        const r = lastComputedR;
        const now = Tone.now();
        try{
          if (windGain) windGain.gain.setValueAtTime(Math.max(0.000001, windBaseLevel(r)), now);
          if (waterGain) waterGain.gain.setValueAtTime(Math.max(0.000001, waterBaseLevel(r)), now);
        } catch(e){}
      }
    });
    document.getElementById(id).addEventListener("change", () => {
      updateFreqLabels();
    });
  });

  // init
  setButtonState();
  applyWhiteByTime(autoTimeBlock());
  refreshWeather();
  tick();
</script>
</body>
</html>
